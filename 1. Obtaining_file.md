First we need to get the data. For this purpose we can extract data from SRA SRP029880 (Kim et al 2016). The objective of this study is to identify a prognostic signature in colorectal cancer (CRC) patients with diverse progression and heterogeneity of CRCs. Authors of this study have tried to identify upregulated genes associated with colorectal cancer (CRC) liver metastasis (CLM). They have conducted 54 Rna-seq samples from 18 CRC patients. For the the purpose of this workflow we will take only 10 samples (5 metastasized colorectal cancer samples and 5 normal colon samples). count data `counts` will be in the form of a matrix with rows representing genes and columns representing samples (5 CRC and 5 normal colon, with one column `width` indicating the genomic length of each gene) 


```r

library(pheatmap)
library(stats)
library(ggplot2)
library(ggfortify)

counts_file <- system.file("extdata/rna-seq/SRP029880.raw_counts.tsv",
                           package = "compGenomRData")
coldata_file <- system.file("extdata/rna-seq/SRP029880.colData.tsv",
                            package = "compGenomRData")
counts <- as.matrix(read.table(counts_file, header = T, sep = '\t'))

> dim(counts)
[1] 19719    11

> counts[1:3,]
       CASE_1 CASE_2 CASE_3 CASE_4 CASE_5 CTRL_1 CTRL_2 CTRL_3 CTRL_4 CTRL_5 width
TSPAN6 776426 371725 612244 456147 513335 559544 489653 332084 238516 634115 12883
TNMD     1483    806   2995    297   1095   4631   1884   4484   1961   3976 15084
DPM1   364919 274342 248740 371045 325628 211173 123204 113606  67338 198331 23689

# Computing CPM

cpm <- apply(subset(counts, select = c(-width)), 2,
             function(x) x/sum(as.numeric(x)) * 10^6)

# as per the definition of cpm, column should add up to a million
> colSums(cpm)
CASE_1 CASE_2 CASE_3 CASE_4 CASE_5 CTRL_1 CTRL_2 CTRL_3 CTRL_4 CTRL_5 
 1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06 

# Computing  RPKM            

# First we need to creat a vector for gene lengts
geneLengths <- as.vector(subset(counts, select = c(width)))

rpkm <- apply(subset(counts, select = c(-width)), 2,
              function(x) {10^9 * x / geneLengths / sum(as.numeric(x))
              })

# Computing TPM

# First we need to find the normalized values of read counts normalized by the gene lengths (geneLengths/1000; i.e., # of 
# reads per base kilo base pair)

rpk <- apply( subset(counts, select = c(-width)), 2,
              function(x) x/(geneLengths/1000))

# Now we can normalize rpk by the sample size and figure out how many transcripts are there out a million reads

tpm <- apply(rpk, 2, function(x) x / sum(as.numeric(x)) * 10^6)

# Now again, as per the definition of tpm, the sample size should add up to a million which indeed is the case.

> colSums(tpm)
CASE_1 CASE_2 CASE_3 CASE_4 CASE_5 CTRL_1 CTRL_2 CTRL_3 CTRL_4 CTRL_5 
 1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06  1e+06 
```

### Explorartory analysis of read count table
+ clustering
  
  It is generally not a good idea to do clustering using all the available genes. It can take lot of time and resources, so instead we do clustering with the help of 100 most variable genes in `tpm` data.
  
  ```r
  # Computing the variance of genes across samples in tpm
  V <- apply(tpm, 1, var)
  
  # sort the V by decreasing order of variance and select top 100 genes.
  
  selectedGenes <- names(V[order(V, decreasing = T)][1:100])
  
  library(pheatmap)
  
  pheatmap(tpm[selectedGenes,], scale = "row", show_rownames = FALSE)
  ```
  
 
 ![image1](https://user-images.githubusercontent.com/85447250/216706661-1fe21cfc-173e-4c6b-bbb3-1e46766a6154.png)
  
  Fig. Clustering and visualization of the topmost variable genes as a heatmap. Columns shows different samples while rows shows 100 topmost variable genes.
  
  We can put some annotations on the heatmap above, primary purpose being to check if the replicates of a sample cluster together or not. Ideally, replicates should cluster together.
  
  ```r
  coldata <- read.table(coldata_file, header = T, sep = '\t',
                      stringsAsFactors = TRUE)
                      
      pheatmap(tpm[selectedGenes,], scale = "row", show_rownames = FALSE, 
         annotation_col = coldata)
 ```
 
 
 
 ![image2](https://user-images.githubusercontent.com/85447250/216751591-c7ee930e-abef-4032-9cad-eeacdb7fa187.png)
 
 Fig. Clustering and visualization of the topmost variable genes as a heatmap with annotation.
 
 
 + Dimensionality reduction: PCA
  
  Apart from heatmap we can also do PCA to confirm if the replicates of a type cluster together. Here too, we should see a clear separation between `CASE` and `CTRL` samples.   
 
 ```r
 # we need to transpose the count matrix, because that is the way a generic PCA calculation function works
 M <- t(tpm[selectedGenes,])
 
 # Making sure the the log function does not have to evaluate a $0$
 
M <- log2(M+1)

pcaResults <- prcomp(M)

pca.plot <- autoplot(pcaResults,
                          data = coldata,
                          colour = 'group')

pca.plot
 ```
![image3](https://user-images.githubusercontent.com/85447250/216831642-37265991-a6d0-433c-9076-52dd1311770c.png)

Fig. PCA plot of CASE and CTRL data using two largest PCs. We can see a clear separation between them.

+ Correlation plot

Another similar approach to look for the similarity between replicates is to compute the correlation between samples.

```r
library(stats)

correlationMatrix <- cor(tpm)
library(pheatmap)
pheatmap(correlationMatrix, annotation_col = coldata)
```

![image4](https://user-images.githubusercontent.com/85447250/216833751-7e383b90-ce01-4fac-9215-4b2701d031d6.png)

Fig. Pairwise correlation of samples displayed as heatmap





### Functional enrichment analysis

 We will use `gost` from **gprofiler2** package to do gene set enrichment analysis. 

```r
term_results <- gost(query = genesOfInterest,
                        organism = "hsapiens",
                        ordered_query = FALSE, 
                        multi_query = FALSE, significant = TRUE,
                        exclude_iea = FALSE, 
                        measure_underrepresentation = FALSE, 
                        evcodes = FALSE, 
                        user_threshold = 0.05, 
                        correction_method = "g_SCS", 
                        domain_scope = "annotated", custom_bg = NULL, 
                        numeric_ns = "", sources = NULL, as_short_link = FALSE)
                        
 # gost() produces a named list; the list includes a data.frame (result) and a metadata object (meta)
 
 > names(term_results)
[1] "result" "meta" 

> dim(term_results$result)
[1] 1688   14

> head(term_results$result,3)
    query significant       p_value term_size query_size intersection_size
1 query_1        TRUE  1.471339e-03         6        526                 6
2 query_1        TRUE  4.991540e-02         6        526                 5
3 query_1        TRUE 9.576567e-111      7463       3790              1957
    precision    recall    term_id source
1 0.011406844 1.0000000 CORUM:7268  CORUM
2 0.009505703 0.8333333 CORUM:7265  CORUM
3 0.516358839 0.2622270 GO:0032501  GO:BP
                                              term_name effective_domain_size
1    HEPACAM-MLC1-Na,K-ATPase-Kir4.1-AQP4-TRPV4 complex                  3385
2 MLC1-Na,K-ATPase-Kir4.1-AQP4-TRPV4-syntrophin complex                  3385
3                      multicellular organismal process                 21092
  source_order       parents
1         2733 CORUM:0000000
2         2730 CORUM:0000000
3         8794    GO:0008150

```

Once we are done with the gene set enrichment analysis, we can visualize what GO, REAC, KEGG are enriched in our gene sets.

```r
plot_object <- gostplot(term_results, capped = TRUE, interactive = TRUE)

plot_obj_table <- publish_gostplot(plot_object, highlight_terms = c("GO:0015850", 
                                                        "REAC:R-HSA-1474244",
                                                        "KEGG:04080"), 
                       width = NA, height = NA, filename = NULL )
plot_obj_table

```
![image9](https://user-images.githubusercontent.com/85447250/217650364-f34224e0-aa58-405e-a2ac-e0ed73cc9d31.png)

Fig. GSEA analysis showing some enriched GO, KEGG, and REAC pathways

We can also get the enriched terms in our data sets as a table. Table below shows top ten terms based on p.values

```r
publish_gosttable(term_results, highlight_terms = head(term_results$result[order(term_results$result$p_value),],10),
                  use_colors = TRUE, 
                  show_columns = c("source", "term_name", "term_size", "intersection_size"),
                  filename = NULL)
                  
```

![image11](https://user-images.githubusercontent.com/85447250/217881068-180c7be1-37f0-472f-9cf4-b58f4149e751.png)

Fig. Table of enriched terms. For representation purpose only top ten are being shown here.























  
  
  

  
  
  
  





